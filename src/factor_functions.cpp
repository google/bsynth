// Generated by rstantools.  Do not edit by hand.

// [[Rcpp::depends(StanHeaders)]]
// [[Rcpp::depends(rstan)]]
// [[Rcpp::plugins(rstan)]]
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::depends(BH)]]
#include <stan/math/prim/fun/Eigen.hpp>
#include <stan/math/prim/meta.hpp>
#include <boost/integer/integer_log2.hpp>
#include <RcppEigen.h>
#ifndef USE_STANC3
#define USE_STANC3
#endif
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model1de0d126c3683_User_defined_functions_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 32> locations_array__ =
  {" (found before start of program)",
  " (in 'User-defined functions', line 27, column 2 to column 42)",
  " (in 'User-defined functions', line 28, column 2 to column 43)",
  " (in 'User-defined functions', line 29, column 9 to column 10)",
  " (in 'User-defined functions', line 29, column 12 to column 13)",
  " (in 'User-defined functions', line 29, column 2 to column 17)",
  " (in 'User-defined functions', line 30, column 2 to column 14)",
  " (in 'User-defined functions', line 32, column 4 to column 35)",
  " (in 'User-defined functions', line 34, column 6 to column 15)",
  " (in 'User-defined functions', line 35, column 6 to column 40)",
  " (in 'User-defined functions', line 33, column 25 to line 36, column 5)",
  " (in 'User-defined functions', line 33, column 4 to line 36, column 5)",
  " (in 'User-defined functions', line 31, column 17 to line 37, column 3)",
  " (in 'User-defined functions', line 31, column 2 to line 37, column 3)",
  " (in 'User-defined functions', line 39, column 25 to column 37)",
  " (in 'User-defined functions', line 39, column 4 to column 37)",
  " (in 'User-defined functions', line 38, column 23 to line 40, column 3)",
  " (in 'User-defined functions', line 38, column 2 to line 40, column 3)",
  " (in 'User-defined functions', line 41, column 2 to column 11)",
  " (in 'User-defined functions', line 26, column 43 to line 42, column 3)",
  " (in 'User-defined functions', line 56, column 4 to column 22)",
  " (in 'User-defined functions', line 57, column 11 to column 12)",
  " (in 'User-defined functions', line 57, column 4 to line 58, column 46)",
  " (in 'User-defined functions', line 59, column 11 to column 12)",
  " (in 'User-defined functions', line 59, column 4 to column 43)",
  " (in 'User-defined functions', line 60, column 11 to column 12)",
  " (in 'User-defined functions', line 60, column 14 to column 15)",
  " (in 'User-defined functions', line 60, column 4 to column 21)",
  " (in 'User-defined functions', line 62, column 6 to column 32)",
  " (in 'User-defined functions', line 61, column 4 to line 62, column 32)",
  " (in 'User-defined functions', line 63, column 4 to column 42)",
  " (in 'User-defined functions', line 55, column 32 to line 64, column 3)"};
template <typename T1__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>,
                stan::base_type_t<T2__>>,-1,-1>
make_F(const int& T, const T1__& diagonal_loadings_arg__, const T2__&
       lower_tri_loadings_arg__, std::ostream* pstream__);
template <typename T1__, typename T2__, typename T3__, typename T4__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_col_vector<T4__>,
                              stan::is_vt_not_complex<T4__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>,
                stan::base_type_t<T2__>, T3__, stan::base_type_t<T4__>>,-1,-1>
make_beta(const int& J, const T1__& off_arg__, const T2__& lambda_arg__,
          const T3__& eta, const T4__& tau_arg__, std::ostream* pstream__);
template <typename T1__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>,
                stan::base_type_t<T2__>>,-1,-1>
make_F(const int& T, const T1__& diagonal_loadings_arg__, const T2__&
       lower_tri_loadings_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>>;
  int current_statement__ = 0;
  const auto& diagonal_loadings = stan::math::to_ref(diagonal_loadings_arg__);
  const auto& lower_tri_loadings =
    stan::math::to_ref(lower_tri_loadings_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int L = std::numeric_limits<int>::min();
    current_statement__ = 1;
    L = stan::math::num_elements(diagonal_loadings);
    int M = std::numeric_limits<int>::min();
    current_statement__ = 2;
    M = stan::math::num_elements(lower_tri_loadings);
    current_statement__ = 3;
    stan::math::validate_non_negative_index("F", "T", T);
    current_statement__ = 4;
    stan::math::validate_non_negative_index("F", "L", L);
    Eigen::Matrix<local_scalar_t__,-1,-1> F =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(T, L, DUMMY_VAR__);
    int idx = std::numeric_limits<int>::min();
    current_statement__ = 6;
    idx = 0;
    current_statement__ = 13;
    for (int j = 1; j <= L; ++j) {
      current_statement__ = 7;
      stan::model::assign(F,
        stan::model::rvalue(diagonal_loadings, "diagonal_loadings",
          stan::model::index_uni(j)), "assigning variable F",
        stan::model::index_uni(j), stan::model::index_uni(j));
      current_statement__ = 11;
      for (int i = (j + 1); i <= T; ++i) {
        current_statement__ = 8;
        idx = (idx + 1);
        current_statement__ = 9;
        stan::model::assign(F,
          stan::model::rvalue(lower_tri_loadings, "lower_tri_loadings",
            stan::model::index_uni(idx)), "assigning variable F",
          stan::model::index_uni(i), stan::model::index_uni(j));
      }
    }
    current_statement__ = 17;
    for (int j = 1; j <= (L - 1); ++j) {
      current_statement__ = 15;
      for (int i = (j + 1); i <= L; ++i) {
        current_statement__ = 14;
        stan::model::assign(F, 0, "assigning variable F",
          stan::model::index_uni(j), stan::model::index_uni(i));
      }
    }
    current_statement__ = 18;
    return F;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T1__, typename T2__, typename T3__, typename T4__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_col_vector<T2__>,
                              stan::is_vt_not_complex<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_col_vector<T4__>,
                              stan::is_vt_not_complex<T4__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T1__>,
                stan::base_type_t<T2__>, T3__, stan::base_type_t<T4__>>,-1,-1>
make_beta(const int& J, const T1__& off_arg__, const T2__& lambda_arg__,
          const T3__& eta, const T4__& tau_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T1__>,
                             stan::base_type_t<T2__>, T3__,
                             stan::base_type_t<T4__>>;
  int current_statement__ = 0;
  const auto& off = stan::math::to_ref(off_arg__);
  const auto& lambda = stan::math::to_ref(lambda_arg__);
  const auto& tau = stan::math::to_ref(tau_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int L = std::numeric_limits<int>::min();
    current_statement__ = 20;
    L = stan::math::cols(off);
    current_statement__ = 21;
    stan::math::validate_non_negative_index("cache", "L", L);
    Eigen::Matrix<local_scalar_t__,-1,1> cache =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(L, DUMMY_VAR__);
    current_statement__ = 22;
    stan::model::assign(cache,
      stan::math::multiply(
        stan::math::tan(
          stan::math::multiply((0.5 * stan::math::pi()), lambda)),
        stan::math::tan(((0.5 * stan::math::pi()) * eta))),
      "assigning variable cache");
    current_statement__ = 23;
    stan::math::validate_non_negative_index("tau_", "J", J);
    Eigen::Matrix<local_scalar_t__,-1,1> tau_ =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(J, DUMMY_VAR__);
    current_statement__ = 24;
    stan::model::assign(tau_,
      stan::math::tan(stan::math::multiply((0.5 * stan::math::pi()), tau)),
      "assigning variable tau_");
    current_statement__ = 25;
    stan::math::validate_non_negative_index("out", "J", J);
    current_statement__ = 26;
    stan::math::validate_non_negative_index("out", "L", L);
    Eigen::Matrix<local_scalar_t__,-1,-1> out =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(J, L, DUMMY_VAR__);
    current_statement__ = 29;
    for (int j = 1; j <= J; ++j) {
      current_statement__ = 28;
      stan::model::assign(out,
        stan::math::multiply(
          stan::model::rvalue(off, "off", stan::model::index_uni(j)),
          stan::model::rvalue(tau_, "tau_", stan::model::index_uni(j))),
        "assigning variable out", stan::model::index_uni(j));
    }
    current_statement__ = 30;
    return stan::math::diag_pre_multiply(cache, stan::math::transpose(out));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>>,-1,-1> 
make_F(const int& T, const Eigen::Matrix<double,-1,1>& diagonal_loadings,
       const Eigen::Matrix<double,-1,1>& lower_tri_loadings, std::ostream*
       pstream__ = 0) {
  return model1de0d126c3683_User_defined_functions_namespace::make_F(T,
           diagonal_loadings, lower_tri_loadings, pstream__);
}
// [[Rcpp::export]]
 Eigen::Matrix<stan::promote_args_t<stan::base_type_t<double>,                 stan::base_type_t<double>, double, stan::base_type_t<double>>,-1,-1> 
make_beta(const int& J, const Eigen::Matrix<double,-1,-1>& off,
          const Eigen::Matrix<double,-1,1>& lambda, const double& eta,
          const Eigen::Matrix<double,-1,1>& tau, std::ostream*
          pstream__ = 0) {
  return model1de0d126c3683_User_defined_functions_namespace::make_beta(J,
           off, lambda, eta, tau, pstream__);
}
